
most shared gitlab runners use a Bash shell
shared gitlab runners' current working directory is the /builds directory
  * from there it clones the directory structure of the project it's working on, starting with the group name, followed by the project name, so: /builds/group/project/etc.
everytime a stage is finished, the Runner starts a new container from scratch to run the next stage, meaning all work done in the previous stage is lost
you can store environment variables under: Settings > CI/CD > Variables
  * you want to name it in all uppercase: VARIABLE_NAME
common CI/CD tasks/usecases that are already available in GitLab as plugins or have been opensourced:
  * semantic-release: used to version pipelines (x.x.x) based on merges and commits to branches with "fix/feat/major:..." prefixes in the commit message
  * you can also navigate under: Settings > Integrations to see a list of useful plugins like with JIRA to link commits and branches to ticket numbers in JIRA
change default branch from main to master: under: Settings > Repository > Default Branch Settings
GitLab has its own Package and Container Registries if you want to leave your dependencies/libraries or Docker Images there
GitLab also has its own Infrastructure Registry if you want to put any IaC modules there like with Terraform or CloudFormation
From the GitLab sidebar:
  * Wiki: basically used for documentation
  * Snippets: basically a place where you can leave useful skeleton code for others
GitLab Owners are different from Maintainers in that:
  * Owners have Group level access while Maintainers are Project level access
  * Owners can manage security policies, billing, manage audits, etc.
Some branching strategies:
  * GitHub Flow: features off of /master
  * Git Flow: features that share an overall similar goal in mind go under a develop branch
    * once the team fully commits to that develop branch being part of a release window, it gets merged into a release branch
    * at this point the release branch is ahead of /master cause it has new code that is going to prod
    * once the release branch has done the full path to prod and it looks good, merge it with master
  * GitLab Flow: comes in 2 flavors:
    * Environment branches: so features off of /master like before, but in addition to that you have branches for each environment (EX: DEV, UAT, QA, PROD, etc.)
    * Release branches: so features off of /master like before, but in addition to that you have branches for each release (so basically Git Flow w/o Development branches)
GitLab has example gitlab-ci.yml templates for you to reference depending on what application you're running
 
---------gitlab-ci.yml---------
script: # Lets you define a script (shared runners mostly use a Bash shell)
        # Everytime this is declared, a new shell is created in a new container (meaning it's a container within a container)
  - bash command 1
  - bash command 2
  - etc.

before_script: # Lets you do some stuff before the sript block
  - bash command 1
  - bash command 2
  - etc.

image: # Overrides the image used to run a runner (by default it's Ruby)
       # Go to docker.hub to look up the specific docker image you need

stages: # Sets which stages to run in what order
  - stage1
  - stage2
  - etc.
...
test:
  stage: stage1
build:
  stage: stage2

artifacts: # Everytime a stage is finished, the Runner starts a new container from scratch to run the next stage, meaning all work done in the previous stage is lost
  paths:   # So to prevent that, you specify a path in the current working directory to artifact so that anything in the path doesn't get deleted
    - builds/etc.

$VARIABLE_NAME # This is how you would call an environment variable like you would in Bash

variables: # Lets you define variables in one place
  VARIABLE_1: value
  VARIABLE_2: value

services: # Lets you create an additional container during build time at the same time as the current container running the current stage
  - service_1
  - service_2
  - etc.

include: # Lets you import other external yml files as part of the current gitlab-ci.yml file 
  - project: # Lets you import a whole other repo from Gitlab
  - ref: # Lets you specify a specific branch, tag, or commit of the repo
  - file: # Lets you specify a specific file of the repo
  - local: # Lets you import a file from the current repo

rules: # Lets you add conditions to when certain stages can be ran
  - if:
  - changes: # A list of file paths; the rule matches if any of the listed files changed.
  - exists: # A list of files; the rule matches if all the listed files exist.
  - when: [on_success, manual, never, etc.]
  - allow_failure:

workflow: # Lets you decide when a pipeline gets ran and when it doesn't. This example prevents pipelines for schedules or push (branches and tags) pipelines.
          # The final when: always rule runs all other pipeline types...
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: $CI_PIPELINE_SOURCE == "push"
      when: never
    - when: always
