good documentation resource: kubernetes.io/docs/reference/generated/kubectl/kubectl-commands

kubectl [COMMAND] [TYPE] [NAME] [FLAGS]
	* TYPE: nodes, pods, replicaset, deployments, namespace, etc.
	* NAME: node_name, pod_name, replicaset_name, deployment_name, namespace_name, cronjob_name etc.

kubectl
	version
	--help
	get [TYPE]
		pods -o wide
			* gets all pods and shows their IP addresses
			* IP addresses are ephermeral for Pods
		pods [NAME] -o jsonpath='{.spec.containers[*].name}'
			* returns a list of all Containers in the specified Pod
		pods --all-namespaces
			* returns all Pods in all Namespaces
			* 1st column is the Namespace, 2nd column is the Pod name
		pods --show-labels
		pods [--selector, -l] [label_name]=[label_value]
			* selects all Pods with the specified label
		pod [NAME]
		pods -n [namespace_name]
			* returns all Pods in the specified Namespace
		cronjob [NAME] -o jsonpath='{.status.lastScheduleTime}'
			* returns the last time the given cronjob was run
	delete [TYPE] [NAME]
		job [job_name]
			* when deleting a Job, you delete the actual Job not just the Pod, cause if you delete its Pod it'll just spin back up again
	run [pod_name] --image=[image_name]
	[create, apply, replace] -f [pod-definition].yml
		* create creates the resource, apply applies the changes to an existing resource (or creates a new resource if it doesn't already exist), replace is the same as apply
		* if you create a resource with create, use replace to update it. If you use apply to create a resource, use apply to update it
	create [TYPE] [NAME] [FLAGS]
		create job [job_name] [--image=image_name] [--schedule="* * * * *"] [-- script_name]
			* when you create a Job, kubernetes creates a Pod with the name you specify
		create cronjob [cronjob_name] [--image=image_name] [--schedule="* * * * *"] [-- script_name]
	describe [TYPE] [NAME]
		* returns info about the resource
	expose deployment [app_name] --type=[NodePort] --name=[nodeport_name] --port=[##] --targetport=[####] --nodeport=[####]
		* the expose command is an alternative way of creating Services using kubectl instead of the deployment.yml files
		* in this example we're creating a new NodePort Service for an existing Deployment
	run -it --rm --restart=Never busybox --image=gcr.io/google-containers/busybox sh
		* BusyBox: 300 of the most common UNIX commands bundled into a single command
		* in this example we're using 'rm'
		* BusyBox does not have 'curl'
	exec -it [pod_name] -c [container_name] -- sh
		* lets you open a new interactive shell terminal (in this case sh) in the specified Container in the specified Pod
		* 'sh' in linux/Bash just means open a new sh shell; you could just replace it with any command as well
	exec -it [pod_name] -- sh
		* lets you open a new interactive shell terminal (in this case sh) in the specified Pod
	scale --replicas=[#] [deployment_name]
		* update # of replicas for a Deployment and performs a new deployment
	autoscale deployment [NAME] --min=[#] --max=[#] --cpu-percent=[##]
		* creates a Horizontal Pod Autoscaler
	logs [pod_name] --all-containers==trouble
		* returns logs for all Containers in the specified Pod
	rollout 
		history deploy [NAME]
			* returns the history of previous deployments
		status deployment [NAME]
			* returns the rollout status of your deployment
		undo deployment [NAME]
			* rollback to the previous deployment shown in the 'rollout histroy' command
	config set-context --current --namespace=[namespace_name]
		* changes the Namespace you're currently in by updating your ~/.kube/config file

helm
	package --sign [./mychart] --key [mykey] --keyring ~/.gnupg/secring.gpg
		* packages a Chart directory into a versioned Chart archive
		* versioned Chart archives are used by Helm package Repositories
	repo
		add [name] https://[link_here]
			* adds a Repository to Helm with the specified name
		update
			* updates local cache with the latest info from your added Repository
	install [release_name] [path_to_chart]
		* installs the specified Chart on the Cluster while also giving it a Release name
	create [name]
		* creates a folder, which itself is a Helm Chart with the specified name
		* contains all the default Helm files and folders needed to run the Helm Chart
	upgrade [release_name] [path_to_chart] --values [path_to_values.yml_file]
		* upgrades an existing Cluster with the specified Chart while also giving it a Release name
	ls
		* lists out all deployed Helm Releases in the Cluster

---KUBERNETES-RELEVANT LINUX COMMANDS---

nslookup [NAME]
	* returns DNS information about the Service with CoreDNS as the default DNS server for kubernetes
iptables -L
	* returns the IP Table used by Kube-Proxy (IP Tables are used by Kube-Proxy by default now, but will be replaced by IPVS)

