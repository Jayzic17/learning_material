resource/object: refers to any of the k8 resources (EX: Pods, Nodes, Namespaces, Deployments, Services, etc.)
Task: An operation that the Container runs; scaling the desired number of Tasks for a Container up/down is how you manage traffic (how many operations can be performed at-a-time) for the Container
Job: creates one or more Pods and will continue to retry execution of the Pods until a specified number of them successfully terminate
Container: a specific service that is built using a Docker Image
Pod: smallest possible kubernetes deployment; contains multiple Docker Containers
Node: a physical machine
Cluster: a group of Nodes
Control Plane: the Master Node that manages the Cluster
	* has the following services installed for managing the Cluster:
		* kube-apiserver: an API server that handles all internal/external API calls for interacting with / managing the Cluster using kubectl or by sending HTTP requests
		* ETCD: key/value DB that contains info used to manage the Cluster
			* contains the current state of any and all resources defined in the cluster
		* controller-manager: the controllers used to run the Cluster
		* kube-scheduler: scheduler used for distributing work/Containers across multiple Nodes
Worker Node: the rest of the Nodes that aren't the Master Node / Control Plane
	* has the following services installed for managing the Node:
		* Kublet: agent run on each Node used to communicate back to the Cluster
			* configures the Container Runtime to: pull images, create namespaces, and run Containers
			* uses PodSpec files to determine what images to pull and Containers to run
		* Kube-proxy: networking component used to allow communication btwn other Worker Nodes and their Containers
			* designed to load balance traffic to Pods
		* Container runtime: used to run Containers
Replicaset: a set of Pods; used for having replicas available for redundancy
Deployment: a set of Pods, except it gives you higher-level control and options on actual rollout and deployment strategy
	* by default it doesn't have any sort of Git Ops, so you can replace it w/ a 3rd party-one like Argo CD, Flux, Jenkin X, etc.
Service: is what allows for Pods to talk to each other and for users to talk to Pods using IP addresses and DNS names
	* ClusterIP: default; allows Pods to talk privatly with each other within the Cluster and NOT outside to user
		* randomly forwards traffic to any Pod set with the target port
	* Headless: sends traffic to a very specific Pod for when you have stateful Pods(reads and writes) and you need writes to go to a specific Pod (EX: a database)
		* it's a Service with no ClusterIP address
		* it does not provide load balancing or proxying
		* it's needed to manage network identity of the stateful Pods by assigning a DNS record to each Pod so you can route traffic to a DNS hostname
	* NodePort: allows users to talk with a Pod within the Cluster
	* LoadBalancer
		* Generally it's recommended to use Kubernetes Ingress instead for load balancing
	* ExternalName: a special Service that does not have selectors and instead uses DNS names
		* you would use this if you only have a DNS to point to (EX: database)
		* it's the same as a ClusterIP, but instead of returing a static IP address it returns a CNAME record
	* A Pod without a Service will have a dynamic IP address, whereas Pods with a Service get a static IP address
		* so when a Pod without a Service dies so does the IP address
Namespace: lets you organize different resources in the same cluster based on their Namespace
	* general usecases:
		* seperate resources based on teams
		* using Namespaces as environments
		* using it for blue/green deployments
		* you can limit usage quotas (cpu/mem/etc.) per Namespace
	* the other option would just have multiple clusters which is fine if you have multiple cloud accounts
	* names of resources need to be unique within a namespace, but not across Namespaces
	* Namespace-based scoping is applicable only for namespaced objects(resources) (Ex: Deployments, Services), but not for Cluster-wide objects (EX: Nodes, Volumes)
		* Single-Namespace Objects: ConfigMaps, Secrets
		* Multi-Namespace Objects: Services, Pods
		* Cluster-Wide Objects: Volumes, Nodes
Kubernetes Ingress: is what takes HTTP/S rules in a request and translates them to point to Services
	* exposes HTTP/S routes from outside the cluster to Services within the cluster
	* traffic routing is controlled by rules defined on the Kubernetes Ingress resource
	* the reason we use Kubernetes Ingress is so we can translate a custom domain on SSL to a Service running within our cluster
	* in order for Kubernetes Ingress to work you need to use an Ingress controller (EX: AWS, GCE, Nginx)
	* Kubernetes Ingress enables you to consolidate the traffic-routing rules into a single resource and runs as part of a Kubernetes cluster
kubectl: the CLI for kubernetes
	* looks in: ~/.kube as it's profile when opening a new shell
Cloud Controller Manager: lets you link Cloud Providers to your kubernetes
Network Policy: acts as a virtual firewall at the namespace or Pod level
ConfigMap: lets you decouple environment variables from your Container images and Pods into key-value pairs
Secret: exact same as ConfigMap, but with encryption
	* by default they're unencrypted in etcd
Horizontal Pod Autoscaler (HPA): Adds more Pods to meet the demand
Vertical Pod Autoscaler (VPA): right-sizes Pods for optimal CPU and memory
Cluster Autoscaler: Adds more Nodes to meet the demand
In-Tree: Plugins provided by default and/or exist in the main repo
Out-of-Tree: Plugins that must be installed manually and extends/replaces default behavior
Endpoints: a Pool of IP addresses; Is what tracks the IP addresses of Pods assigned to a Service
	* Endpoint Slices: Endpoint pool broken up into smaller manageable segments
Selectors:
	* 3 types:
		* Label Selector: select k8 objects based on the Label
		* Field Selector: select k8 objects based on data, metadata, status, etc.
		* Node Selector: select specific Nods for where you want to put your Pods
Annotations: Similar to Labels in that it's used to identify things, but it's specific use-case is to attach metadata on to objects to allow for things like controllers, clients, tools, and libraries to work
gRPC (remote procedure call): the networking protocol that k8 uses to work
	* if you see any files with the .proto extension that's what it is
Minikube: sets up a local single-Node k8 cluster for learning purposes
	* running off a VM
	* intended just for development purposes
k3s: a lightweight tool used to run prod-level kubernetes workloads for testing in a VM
k3d: lightweight wrapper that runs k3s in a docker Container instead of a VM
Kind: same idea as Minikube but it instead runs off Docker Containers as Nodes instead of VM's
MicroK8s: another lightweight k8 distribution like Minikube and Kind; also good for testing prod-level workloads
Managed Kubernetes providers:
	* Google Kubernetes Engine (GKE)
	* Amazon Elastic Kubernetes (EKS)
	* Azure Kubernetes (AKS)
Container Runtime Interface: is what allows you to run a variety of different Container Runtimes (EX: ContainerD)
	* ContainerD: makes it easier for projects like kubernetes to access the low-level Docker elements they need instead of actually using Docker
		* Images you build with Docker aren't really Docker images, cause Docker now uses the ContainerD runtime
Container Runtime: is what runs Containers (EX: runC)
	* 2 types:
		* Native Runtimes: uses CGroups for isolation
		* Sandboxed / Virtualized Runtimes: provides securtiy benefits through virtual isolation; uses VM's for isolation
CGroups (control groups): lets you group processes(by processes I just mean running Linux programs) together to apply certain kinds of limits:
	* EX: setting resource limits, assigning priority per CGroup, accounting for billing, control processes based on CGroup
Container Storage Interface (CSI): standardizes how Container Orchestration tools like Kubernetes connect to storage providers for block storage (EX: AWS EBS)
MinIO: Kubernetes' version of object storage, which is also compatible with AWS S3
types of volumes that Kubernetes supports:
	* Persistent Volumes: attached to a Pod; data will persist even if Pod is terminated
		* mounting a Persistent Volume directly on a Pod is not allowed
	* Ephermeral Volumes: attached to a Pod; data only exists as long as the Pod isn't terminated
	* Projected Volumes: maps several existing volumes into a same directory
	* Volume Snapshot: a snapshot of a volume for rollbacks or backup
Traffic Policies: lets you determine how ingress traffic is routed
	* 2 types:
		* External Traffic Policy: how traffic from external sources is routed and has 2 values:
			* Cluster: route external traffic to all ready Endpoints
			* Local: only route to ready Node-local Endpoints
		* Internal Traffic Policy: how traffic from internal sources is routed (same 2 values as External Traffic Policy)
CoreDNS: the default DNS server for Kubernetes
4 levels of load balancing in kubernetes:
	* External load balancer: 3rd party load balancer (EX: AWS ELB/ALB)
	* Kubernetes Ingress: lets you control the load balancing algorithm and assign weights
	* Services: lets you persist Pods and set dynamic weights
	* internal load balancing (IP Tables/IPVS) at the Container/Pod level (randomly distributed) used by Kube-proxy
		* is handled in 1 of 4 ways:
			* IP Tables (default): generic table of IP addresses; very generic firewall
				* has trouble scaling since it's capped out at 5000 Nodes per cluster, in which case you would switch to IPVS
			* NFT Tables: successor to IP Tables; more flexible and scalable
			* IPVS (will become the default soon): specifically designed for load balancing; uses hash tables; unlimited scaling
			* Userspaces: legacy (don't use it)
Probes: used to detect the state of a Container
	* 3 types:
		* Liveness Probe: used by Kubelet to know when to restart a Container
		* Readiness Probe: used by Kubelet to know when a Container is ready to start accepting traffic
		* Startup Proble: used by Kubelet to know when a Container has started
Forward Proxy: bunch of servers egressing traffic, but it has to pass through a single proxy first
Reverse Proxy: Ingress traffic has to pass through a single proxy first before it reaches a bunch of servers (EX: a load balancer)
Container Networking Interface (CNI): specification standard for writing plugins for Containers
	* so if you want to use a plugin for a Container, the flow would look like: plugin -> CNI -> Container Runtime -> Container
Service Mesh: manages service-to-service communication for microservices (service here meaning an application, not refering to the k8 resource)
	* it also provides traffic management, load balancing, observability, and certs
	* for use in a kubernetes cluster, a Service Mesh Control Plane is created, along with a proxy Container installed in each Pod as a sidecar
	* popular Service Meshes for use with Kubernetes:
		* Istio (the most popular), which uses Envoy as its proxy
		* Kuma, which also uses Envoy as the proxy
		* Linkerd, which uses Linkerd2-proxy
Network Interface Card (NIC): the physical port you plug your ethernet cable into
	* Cloud Providers have virtual NICs for your VMs to connect to a virtual network
	* eth0: the 1st ethernet interface attached to your VM
Network Namespace: an abstraction on top of the ethernet interface to provide a logical networking stack with it's own routes, firewall rules, and network devices
	* Linux by default has one Network Namespace called the Root Network Namespace
kubernetes cluster networking:
	* all Pods can communicate with all other Pods w/o using NAT 
	* all Nodes can communicate with all Pods w/o using NAT 
	* the IP that a Pod sees itself as, is the same IP that others see it as 
	* 4 types of network communication for clusters:
		* Container -> Container
			* Containers in the same Pod have the same IP address and port space
			* Containers can communicate with each other via localhost via different ports 
		* Pod -> Pod
			* depends whether or not the Pods are on the same Node
				* on the same Node, a veth is used to communicate from the Pod Network Namespace to the Root Network Namespace
					* in the Root Network Namespace a Bridge (Bridging) is used to allow all Pod Network Namespaces to talk to other Pods
						* Routing: allows multiple networks to communicate independently and yet remain separate using a router
						* Bridging: connects 2 separate networks as if they were a single network using a Bridge
					* Pods can see all other Pods, and communicate using their IP addresses
				* accross different Pods, it's network-specific based on the situation
					* in the case of AWS they have their own implementation of the Container Networking Interface (CNI) using the Amazon VPC Container Network Interface plugin for Kubernetes
		* Pod -> Service
			* when a Pod dies its IP address changes, so a Service creates a static IP and then uses IP Tables that are installed on the Node to perform NAT and load balancing to other Pods
		* External -> Service
Virtual Ethernet Devices (veths): virtual ethernet devices; act as tunnels btwn Network Namespaces
Each Pod has a resolve.conf file to help with DNS resolving in ~/etc/
RBAC stands for role-based access controls
	* with RBAC there are only allow rules; everything is deny by default
kubernetes access controls and permissions:
	* Role: permissions for a particular Namespace
	* ClusterRole: permissions accross all Namespaces
	* Role Binding and Cluster Role Binding: is what links a set of permissions to a particular user, group, or service(machine user)
	* Network Policy: virtual firewalls for Pod communication
		* you would have to download a network plugin that supports Network Policies in order to create one (EX: Calico) 
		* has 3 scopes:
			* pod-to-pod
			* namespaces
			* specific IPs
		* you would use Selectors to match the resources you want for the Networking Policy to be applied to
Kubernetes Event-Driven Autoscaling (KEDA): lets you autoscale based on event data (EX: from AWS like: CloudWatch or SQS Queue)
OpenTelemetry: standardizes the way observability data is collected
	* uses Wire protocol: the protocol that gets the data from point A to point B (EX: SOAP)
Trace: the data execution path taken through a system at each point
Span: how the workload is distributed through each point in the Trace
System Logs: logs about the Cluster
Klog: the kubernetes logging library
	* generateds log messages for the kuberentes system components
TestKube: kuberetes testing framework
Helm: package manager for Kubernetes
	* broadly composed of 3 main concepts:
		* Chart: contains all the resource definitions necessary to run the application inside the Cluster
			* Chart.yaml: file containing info about the Chart
			* LICENSE: (optional); plain text file containing the license for the Chart
			* values.yaml: the default conifguration values for the Chart
				* values-[env].yaml: environment overrides for the Chart
			* values.schema.json: (optional); a json schema for imposing a structure on the values.yaml file
			* charts/: a directory containing any Charts upon which this Chart depends on
			* crds/: custom resource definitions
			* templates/: a directory of templates that, when combined with values (values.yaml), will generate valid Kubernetes .yaml files
		* Repository: the place where Charts can be collected and shared
		* Release: an instance of a Chart running in a Kubernetes Cluster
	* Artifact Hub: where you can find published Helm Charts
Kustomize: allows you to Overlay(override) and to Patch(patch) kubernetes .yaml files; is an alternative to Helm
	* Common Values: help keep labels, annotations, and names consistent
	* Generators: help create and map ConfigMaps and Secrets to your Pods
	* Base: the folder that contains all the OG kubernetes .yml files, plus an additional kustomization.yml file
	* Overlays: the folder that contains a folder for each environment you want to Patch changes to
	* Patch: the actual changes in the kustomization.yml files
	* kustomization.yml options:
		* resources: the kubernetes .yml files that Kustomize should import (contained in your Base folder)
		* commonLabels, commonAnnotations, namePrefix, and nameSuffix: sets the naming for the resources you're importing
			* this removes the need for labels, annotations, etc. from the files in your Base folder, as well as the selectors
		* configMapGenerator and secretsGenerator:
			* so instead of creating secret-definition.ymls and configmap-definition.ymls, you create a Generator in the kusomization.yml file, and the secret-definition.ymls and configmap-definition.ymls...
			* ...just become a config.properties file w/ a bunch of key/value pairs
	* Kustomize commands in kubectl:
		* kubectl kustomize [path_to_kustomization.yml]: basically the equivalent to a terraform plan
		* kubectl apply -k [path_to_kustomization.yml]: basically the equivalent to a terraform apply
kubernetes CD solutions: Flux and Argo:
	* Argo: native kubernetes CD; supports both Helm and Kustomize
		* monitors the live state of your Clusters against the kubernetes .yml files in your Git Repos and can automatically/manually sync them to your Cluster
	* argo CLI commands:
		* argocd app list: lists out all Argo deployments and their status
		* argocd app create [argocd_deployment_name] \
							--repo [link_to_repo_w_kubernetes_.yml_files] \
							--path [path_to_folder_containing_kustomization.yml_or_values.yml] \
							--dest-service [link_to_kubernetes_cluster] \
							--dest-namespace [namespace]
		* argocd app sync [argocd_deployment_name]
kubernetes deployment types:
	* Recreate: tear down and recreate all Pods
	* RollingUpdate: updates Pods a few at-a-time
	* Canary:
		* create a new group of Pods w/ the new version, alongside the existing Pods in the cluster
		* redirect a subset of users to the new group
		* if it's all good, then delete all old Pods and create all new one's w/ the new version
	* A to B Testing: uses a Canary or Blue/Green method of deployment, but instead of redirecting the subset of users for a short amount of time like w/ Canary or Blue/Green, it happens for a long period of time
	* Dark Launch: instead of deploying new features as its own new image, have it so that it's a feature flag you can toggle on and off whenever you want
	
	
